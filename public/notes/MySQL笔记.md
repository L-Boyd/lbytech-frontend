# 锁



## 全局锁

## 表级锁

+ 表锁
+ 元数据锁
+ 意向锁
+ AUTO-INC锁

## 行级锁

+ Record Lock：记录锁，也就是仅仅把一条记录锁上；
+ Gap Lock：间隙锁，锁定一个范围，但是不包含记录本身；
+ Next-Key Lock：Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。
+ 插入意向锁



## 例子

```sql
select ... lock in share mode;//对读取的记录加共享锁（s锁）
select ... for update;//对读取的记录加排他锁（x锁）
update table ... where id = 1;//对操作的记录加独占锁
delete from table where id = 1;//对操作的记录加独占锁
```





# 索引



## 分类

+ 数据结构
  1. B+树索引
  2. 哈希索引
  3. 全文索引/倒排索引
  4. R-树索引
+ InnoDB B+树
  1. 聚簇索引
  2. 非聚簇索引
+ 索引性质
  1. 普通索引、二级索引、辅助索引
  2. 主键索引
  3. 联合索引
  4. 唯一索引
  5. 全文索引
  6. 空间索引



## 文件排序

+ 排序字段命中索引：索引排序

+ 其他：文件排序

  + 数据量少：内存中排序

    + 单路排序

      select列的数据长度没超过```max_length_for_sort_data```(默认4096字节)，把select字段放到```sort_buffer```中。如```select a,b,c from t where a = 'xx' order by b```，放a,b,c进行排序，排序后，直接得到结果集，返回给客户端

    + 双路排序

      select列的数据长度超过```max_length_for_sort_data```，把row_id（主键）+排序字段放到```sort_buffer```中排序。如```select a,b,c from t where a = 'xx' order by b```，只放id和b进行排序，排序后，再通过id回表查询得到a,b,c，再返回给客户端

  + 数据量大：磁盘文件中外部排序

    + 归并排序



# 存储引擎

1. InnoDB
   + 支持事务、行级锁、外键
   + 提供高并发性能
2. MyISAM
   + 不支持事务和外键，支持表级锁
   + 适合读取多，更新少场景
3. MEMORY
   + 数据存在内存中，速度快，但数据在服务器重启后丢失
   + 适用于临时数据存储或快速缓存





# SQL



## 执行过程

1. 通过**连接器**校验权限
2. 利用**分析器**进行SQL语句的词法分析和语法分析，构建解析树
3. 使用**优化器**选择合适的索引和表连接顺序，最终选择一个最佳的执行计划
4. 利用**执行器**，调用存储引擎查询数据，返回结果集给客户端



